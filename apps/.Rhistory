install.packages("SMSdata")
knitr::opts_chunk$set(echo = TRUE)
bank<-read.table("mvadata/bank2")
bank<-read.table("/mvadata/bank2")
getwd()
setwd("/Users/xiaoxi/Study/multivariate")
2
bank<-read.table("/mvadata/bank2")
bank<-read.table("/mvadata/bank2.dat")
bank<-read.table("mvadata/bank2.dat")
bank
d=data.frame(price=bank2[,6],kateg=rep(1:2,each=100))
bank2<-bank
d=data.frame(price=bank2[,6],kateg=rep(1:2,each=100))
d[,2]=factor(d[,2], levels=1:2, labels=c("Genuine","Counterfeit"))
boxplot(price~kateg,main="Swiss bank notes",data=d)
# load library
library(stats)
bank = bank2[,6] #sixth column (X6)
x1   = bank[1:100] #genuine bank notes
x2   = bank[101:200] #counterfeit bank notes
fh1  = density(x1,kernel="gaussian",bw=0.1885) #kernel density estimation for the diagonal of genuine bank notes
fh2  = density(x2,kernel="gaussian",bw=0.2352) #kernel density estimation for the diagonal of counterfeit bank notes
plot(fh1,xlim=c(137.5,143),ylim=c(0.0,0.9),xlab="Counterfeit    /    Genuine",ylab="density estimates for diagonals",main="Swiss bank notes")
lines(fh2,lty=2)
sigma1<-sd(x1)
bw1<-sigma1*1.06/100^(0.2)
bw1
sigma1<-sd(x1)*(99/100)^(0.5)
bw1<-sigma1*1.06/100^(0.2)
bw1
bw1<-sigma1*1.06*100^(-0.2)
bw1
xb<-mean(x1)
sum((x1-xb)^2)->var
(var/100)^0.5*1.06*100^(-0.2)
sigma2<-sd(x2)*(99/100)^(0.5)
bw2<-sigma2*1.06*100^(-0.2)
bw2
sigma1<-sd(x1)
bw1<-sigma1*1.06*100^(-0.2)
sigma2<-sd(x2)
bw2<-sigma2*1.06*100^(-0.2)
bw2
bw1<-sigma1*1.06*100^(-0.2)
fh1  = density(x1,kernel="gaussian",bw=0.1885) #kernel density estimation for the diagonal of genuine bank notes
sigma2<-sd(x2)
bw2<-sigma2*1.06*100^(-0.2)
fh2  = density(x2,kernel="gaussian",bw=0.2352) #kernel density estimation for the diagonal of counterfeit bank notes
plot(fh1,xlim=c(137.5,143),ylim=c(0.0,0.9),xlab="Counterfeit    /    Genuine",ylab="density estimates for diagonals",main="Swiss bank notes")
lines(fh2,lty=2)
bank2<-read.table("mvadata/bank2.dat")
bank = bank2[,6] #sixth column (X6)
x1   = bank[1:100] #genuine bank notes
x2   = bank[101:200] #counterfeit bank notes
sigma1<-sd(x1)
bw1<-sigma1*1.06*100^(-0.2)
fh1  = density(x1,kernel="gaussian",bw=0.1885) #kernel density estimation for the diagonal of genuine bank notes
sigma2<-sd(x2)
bw2<-sigma2*1.06*100^(-0.2)
fh2  = density(x2,kernel="gaussian",bw=0.2352) #kernel density estimation for the diagonal of counterfeit bank notes
plot(fh1,xlim=c(137.5,143),ylim=c(0.0,0.9),xlab="Counterfeit    /    Genuine",ylab="density estimates for diagonals",main="Swiss bank notes")
lines(fh2,lty=2)
sigma1<-sd(x1)*(99/100)^(0.5)
bw1<-sigma1*1.06*100^(-0.2)
bw1
sigma2<-sd(x2)*(99/100)^(0.5)
bw2<-sigma2*1.06*100^(-0.2)
sigma2<-sd(x2)*(99/100)^(0.5)
bw2<-sigma2*1.06*100^(-0.2)
bw2
fh2  = density(x2,kernel="gaussian",bw=bw2) #kernel density estimation for the diagonal of counterfeit bank notes
bank2<-read.table("mvadata/bank2.dat")
bank = bank2[,6] #sixth column (X6)
x1   = bank[1:100] #genuine bank notes
x2   = bank[101:200] #counterfeit bank notes
sigma1<-sd(x1)*(99/100)^(0.5)
bw1<-sigma1*1.06*100^(-0.2)
fh1  = density(x1,kernel="gaussian",bw=bw1) #kernel density estimation for the diagonal of genuine bank notes
sigma2<-sd(x2)*(99/100)^(0.5)
bw2<-sigma2*1.06*100^(-0.2)
fh2  = density(x2,kernel="gaussian",bw=bw2) #kernel density estimation for the diagonal of counterfeit bank notes
plot(fh1,xlim=c(137.5,143),ylim=c(0.0,0.9),xlab="Counterfeit    /    Genuine",ylab="density estimates for diagonals",main="Swiss bank notes")
lines(fh2,lty=2)
#one bandwidth for two groups
sigma<-sd(bank)*(199/200)^(0.5)
bw<-sigma*1.06*200^(-0.2)
bw
fh1  = density(bank,kernel="gaussian",bw=bw) #kernel density estimation for the diagonal of genuine bank notes
#one bandwidth for two groups
sigma<-sd(bank)*(199/200)^(0.5)
bw<-sigma*1.06*200^(-0.2)
fh1 = density(x1,kernel="gaussian",bw=bw) #kernel density estimation for the diagonal of genuine bank notes
fh2  = density(x2,kernel="gaussian",bw=bw) #kernel density estimation for the diagonal of counterfeit bank notes
plot(fh1,xlim=c(137.5,143),ylim=c(0.0,0.9),xlab="Counterfeit    /    Genuine",ylab="density estimates for diagonals",main="Swiss bank notes")
lines(fh2,lty=2)
#recreate fig1.9
fh1  = density(x1,kernel="gaussian",bw=bw1) #kernel density estimation for the diagonal of genuine bank notes
fh2  = density(x2,kernel="gaussian",bw=bw2) #kernel density estimation for the diagonal of counterfeit bank notes
plot(fh1,xlim=c(137.5,143),ylim=c(0.0,0.9),xlab="Counterfeit    /    Genuine",ylab="density estimates for diagonals",main="Swiss bank notes")
lines(fh2,lty=2)
#recreate fig1.9
fh1  = density(x1,kernel="gaussian",bw=bw1) #kernel density estimation for the diagonal of genuine bank notes
fh2  = density(x2,kernel="gaussian",bw=bw2) #kernel density estimation for the diagonal of counterfeit bank notes
plot(fh1,xlim=c(137,143),ylim=c(0.0,0.9),xlab="Counterfeit    /    Genuine",ylab="density estimates for diagonals",main="Swiss bank notes")
lines(fh2,lty=2,col=2)
#recreate fig1.9
fh1  = density(x1,kernel="gaussian",bw=bw1) #kernel density estimation for the diagonal of genuine bank notes
fh2  = density(x2,kernel="gaussian",bw=bw2) #kernel density estimation for the diagonal of counterfeit bank notes
plot(fh1,xlim=c(137,143),ylim=c(0.0,0.9),xlab="Counterfeit    /    Genuine",ylab="",main="Swiss bank notes")
lines(fh2,lty=2,col=2)
carc<-read.table("mvadata/car.dat")
car<-read.table("mvadata/car.dat")
carc<-read.table("mvadata/carc.dat")
car
carc
View(car)
View(carc)
library(MASS)
carc<-read.table("mvadata/carc.dat")
library(MASS)
parcoord(sapply(carc[,1:13],as.numeric),col=as.numeric(carc$C),lty=as.numeric(carc$C)-(carc$C=="Europe")+(carc$C=="Japan"),lwd=1,main="Cars data")
carc
carc<-read.table("mvadata/car.dat")
carc
carc<-read.table("mvadata/car.dat")
library(MASS)
parcoord(sapply(carc[,1:13],as.numeric),col=as.numeric(carc$C),lty=as.numeric(carc$V14),lwd=1,main="Cars data")
carc<-read.table("mvadata/car.dat")
library(MASS)
parcoord(sapply(carc[,1:13],as.numeric),col=as.numeric(carc$C),lty=as.numeric(carc$V14),lwd=1,main="Cars data")
?parcoord
carc<-read.table("mvadata/car.dat")
carc<-read.table("mvadata/carc.dat")
carc<-read.table("mvadata/carc.dat")
library(MASS)
parcoord(sapply(carc[,2:14],as.numeric),col=as.numeric(carc$C),lty=as.numeric(carc$V14),lwd=1,main="Cars data")
carc<-read.table("mvadata/carc.dat")
library(MASS)
parcoord(sapply(carc[,2:14],as.numeric),col=as.numeric(carc$V14),lty=as.numeric(carc$V14),lwd=1,main="Cars data")
pop<-read.table("mvadata/yearpop.dat")
pop
install.packages(pkgs="http://www.karlin.mff.cuni.cz/~hlavka/sms2/MSES_1.1.tar.gz",repos=NULL,type="source")
install.packages(pkgs="http://www.karlin.mff.cuni.cz/~hlavka/sms2/MSES_1.1.zip",repos=NULL)
library(MSES);SMSboxbank6()
install.packages(pkgs="http://www.karlin.mff.cuni.cz/~hlavka/sms2/SMSdata_1.0.tar.gz", repos=NULL, type="source")
install.packages(pkgs="http://www.karlin.mff.cuni.cz/~hlavka/sms2/SMSdata_1.0.zip",repos=NULL)
library(SMSdata);data(bank2)
help("bank2")
help(yearpop)
help("yearpop")
data(yearpop)
library(SMSdata);data(yearpop)
library(SMSdata)
data("annualpopu")
help("annualpopu")
library(SMSdata)
library(SMSdata)
data("annualpopu")
boxplot(annualpopu$Inhabitants~annualpopu$Year)
library(SMSdata)
data("annualpopu")
boxplot(annualpopu$Inhabitants)
t<-annualpopu[10:19,2:3]
library(SMSdata)
data(annualpopu)
t<-annualpopu[10:19,2:3]
colour<-rep(1:2,each=5)
curve((t[1,1]/sqrt(2)+t[1,2]*sin(x)-42000)/100,xlim=c(-3.15,3.15),ylim=c(3,27),ylab="42000+Y*100",main="Andrew's curves")
for(i in 1:10){curve((t[i,1]/sqrt(2)+t[i,2]*sin(x)-42000)/100,add=TRUE,col=colour[i])}
library(SMSdata)
data("annualpopu")
boxplot(annualpopu$Inhabitants)
t<-annualpopu[10:19,2:3]
colour<-rep(1:2,each=5)
curve((t[1,1]/sqrt(2)+t[1,2]*sin(x)-42000)/100,xlim=c(-3.15,3.15),ylim=c(3,27),ylab="42000+Y*100",main="Andrew's curves")
for(i in 1:10){curve((t[i,1]/sqrt(2)+t[i,2]*sin(x)-42000)/100,add=TRUE,col=colour[i])}
library(SMSdata)
data("annualpopu")
boxplot(annualpopu$Inhabitants)
t<-annualpopu[10:19,2:3]
colour<-rep(1:2,each=5)
curve((t[1,1]/sqrt(2)+t[1,2]*sin(x)-42000)/100,xlim=c(-3.15,3.15),ylim=c(3,27),ylab="42000+Y*100",main="Andrew's curves")
for(i in 1:10){curve((t[i,1]/sqrt(2)+t[i,2]*sin(x)-42000)/100,add=TRUE,col=colour[i])}
annualpopu
plot(Unemplyed~Inhabitants,data=annualpopu)
plot(Unemployed~Inhabitants,data=annualpopu)
plot(Inhabitants~Year,data=annualpopu)
hist(annualpopu$Inhabitants)
hist(annualpopu$Inhabitants,bins=20)
hist(annualpopu$Inhabitants,bin=20)
?hist
hist(annualpopu$Inhabitants,breaks=20)
hist(annualpopu$Inhabitants,breaks=30)
hist(annualpopu$Inhabitants,breaks=50)
hist(annualpopu$Inhabitants,breaks=10)
rep(1:2,each=5)
annualpopu[10:19,2:3]
t
plot(Inhabitants~Year,data=annualpopu)
hist(annualpopu$Inhabitants,breaks=10)
library(SMSdata)
data("annualpopu")
boxplot(annualpopu$Inhabitants)
t<-annualpopu[10:19,2:3]
colour<-rep(1:2,each=5)
curve((t[1,1]/sqrt(2)+t[1,2]*sin(x)-42000)/100,xlim=c(-3.15,3.15),ylim=c(3,27),ylab="42000+Y*100",main="Andrew's curves")
for(i in 1:10){curve((t[i,1]/sqrt(2)+t[i,2]*sin(x)-42000)/100,add=TRUE,col=colour[i])}
#give five-number summaries of variables population and unemployment
summary(annualpopu$Inhabitants)
summary(annualpopu$Unemployed)
#in 17.1 draw for both variables population and unemployment +in 17.2 choose 20 data points +highlight advantages/ disadvantages/usefulness of using these four types of plots for this dataset
#boxplot for unemployment
boxplot(annualpopu$Unemployed)
library(SMSdata)
data("annualpopu")
#boxplot for inhabitants
boxplot(annualpopu$Inhabitants)
#boxplot for unemployment
boxplot(annualpopu$Unemployed)
t<-annualpopu[5:24,2:3]
colour<-rep(1:2,each=5)
curve((t[1,1]/sqrt(2)+t[1,2]*sin(x)-42000)/100,xlim=c(-3.15,3.15),ylim=c(3,27),ylab="42000+Y*100",main="Andrew's curves")
for(i in 1:10){curve((t[i,1]/sqrt(2)+t[i,2]*sin(x)-42000)/100,add=TRUE,col=colour[i])}
library(SMSdata)
data("annualpopu")
#boxplot for inhabitants
boxplot(annualpopu$Inhabitants)
#boxplot for unemployment
boxplot(annualpopu$Unemployed)
t<-annualpopu[5:24,2:3]
colour<-rep(1:2,each=5)
curve((t[1,1]/sqrt(2)+t[1,2]*sin(x)-42000)/100,xlim=c(-3.15,3.15),ylab="42000+Y*100",main="Andrew's curves")
for(i in 1:10){curve((t[i,1]/sqrt(2)+t[i,2]*sin(x)-42000)/100,add=TRUE,col=colour[i])}
library(SMSdata)
data("annualpopu")
#boxplot for inhabitants
boxplot(annualpopu$Inhabitants)
#boxplot for unemployment
boxplot(annualpopu$Unemployed)
t<-annualpopu[5:24,2:3]
colour<-rep(1:2,each=5)
curve((t[1,1]/sqrt(2)+t[1,2]*sin(x)-42000)/100,ylab="42000+Y*100",main="Andrew's curves")
for(i in 1:10){curve((t[i,1]/sqrt(2)+t[i,2]*sin(x)-42000)/100,add=TRUE,col=colour[i])}
library(SMSdata)
data("annualpopu")
#boxplot for inhabitants
boxplot(annualpopu$Inhabitants)
#boxplot for unemployment
boxplot(annualpopu$Unemployed)
t<-annualpopu[5:24,2:3]
colour<-rep(1:2,each=5)
curve((t[1,1]/sqrt(2)+t[1,2]*sin(x)-42000)/100,xlim=c(-3.15,3.15),ylim=c(0,27),ylab="42000+Y*100",main="Andrew's curves")
for(i in 1:10){curve((t[i,1]/sqrt(2)+t[i,2]*sin(x)-42000)/100,add=TRUE,col=colour[i])}
library(SMSdata)
data("annualpopu")
#boxplot for inhabitants
boxplot(annualpopu$Inhabitants)
#boxplot for unemployment
boxplot(annualpopu$Unemployed)
t<-annualpopu[5:24,2:3]
colour<-rep(1:2,each=5)
curve((t[1,1]/sqrt(2)+t[1,2]*sin(x)-42000)/100,xlim=c(-3.15,3.15),ylim=c(-10,27),ylab="42000+Y*100",main="Andrew's curves")
for(i in 1:10){curve((t[i,1]/sqrt(2)+t[i,2]*sin(x)-42000)/100,add=TRUE,col=colour[i])}
library(SMSdata)
data("annualpopu")
#boxplot for inhabitants
boxplot(annualpopu$Inhabitants)
#boxplot for unemployment
boxplot(annualpopu$Unemployed)
t<-annualpopu[5:24,2:3]
colour<-rep(1:2,each=5)
curve((t[1,1]/sqrt(2)+t[1,2]*sin(x)-42000)/100,xlim=c(-3.15,3.15),ylim=c(-20,27),ylab="42000+Y*100",main="Andrew's curves")
for(i in 1:10){curve((t[i,1]/sqrt(2)+t[i,2]*sin(x)-42000)/100,add=TRUE,col=colour[i])}
library(SMSdata)
data("annualpopu")
#boxplot for inhabitants
boxplot(annualpopu$Inhabitants)
#boxplot for unemployment
boxplot(annualpopu$Unemployed)
t<-annualpopu[5:24,2:3]
colour<-rep(1:2,each=5)
curve((t[1,1]/sqrt(2)+t[1,2]*sin(x)-42000)/100,xlim=c(-3.15,3.15),ylim=c(-20,27),ylab="42000+Y*100",main="Andrew's curves")
for(i in 1:20){curve((t[i,1]/sqrt(2)+t[i,2]*sin(x)-42000)/100,add=TRUE,col=colour[i])}
library(SMSdata)
data("annualpopu")
#boxplot for inhabitants
boxplot(annualpopu$Inhabitants)
#boxplot for unemployment
boxplot(annualpopu$Unemployed)
t<-annualpopu[5:24,2:3]
colour<-rep(1:2,each=10)
curve((t[1,1]/sqrt(2)+t[1,2]*sin(x)-42000)/100,xlim=c(-3.15,3.15),ylim=c(-20,27),ylab="42000+Y*100",main="Andrew's curves")
for(i in 1:20){curve((t[i,1]/sqrt(2)+t[i,2]*sin(x)-42000)/100,add=TRUE,col=colour[i])}
library(SMSdata)
data("annualpopu")
#boxplot for inhabitants
boxplot(annualpopu$Inhabitants)
#boxplot for unemployment
boxplot(annualpopu$Unemployed)
t<-annualpopu[5:24,2:3]
colour<-rep(1:2,each=10)
curve((t[1,1]/sqrt(2)+t[1,2]*sin(x)-42000)/100,xlim=c(-3.15,3.15),ylim=c(-15,35),ylab="42000+Y*100",main="Andrew's curves")
for(i in 1:20){curve((t[i,1]/sqrt(2)+t[i,2]*sin(x)-42000)/100,add=TRUE,col=colour[i])}
head(carc)
data(carc)
carc
library(KernSmooth)
data(carc)
x = cbind(carc[,1], carc[,2], carc[,8], carc[,9])
y = c("price", "mileage", "weight", "length")
p = dim(x)[2]
n = dim(x)[1]
par(mfrow=c(p,p), mar = 0.2 + c(0,0,0,0))  # creates display pxp with margins=0.2
for (k in 0:15) {
i = (k %/% 4) + 1  # div, ith raw
j = (k %% 4) + 1   # mod, jth column
if (i>j) {
plot(x[,i]~x[,j], xlab = "", ylab = "", axes=FALSE, frame.plot=TRUE,pch=as.numeric(carc$C)-1-(carc$C=="Europe")+(carc$C=="Japan"),cex=1.5)
}
if (i<j) {
xx=cbind(x[,i],x[,j])
nd=15                                 # number of grid points in each dimension
nd=matrix(1,1,nrow = dim(xx)[2])*nd   # matrix 2x1 with numbers of grid points in each dimension
d=c(apply(t(xx), 1, max) - apply(t(xx), 1, min))/(nd-1)
h=c(2.6073*sqrt(var(x[,i]))*n^(-1/6),2.6073*sqrt(var(x[,j]))*n^(-1/6)) # bandwidth a la Scott's rule of thumb
minmaxx = c(min(x[,i]), max(x[,i]))
minmaxy = c(min(x[,j]), max(x[,j]))
est = bkde2D(xx, bandwidth=h/2, gridsize=nd, truncate=TRUE, range.x=list(minmaxx, minmaxy))   # estimates 2dimensional density
contour(est$x1, est$x2, est$fhat,  col="blue", axes=FALSE, frame.plot=TRUE)
}
if (i == j) {
plot(0~0,xlab = "", ylab = "", axes=FALSE, xlim=c(1,5), ylim=c(1,5), frame.plot=TRUE)
text(2,4.5, y[i], cex=1.5)  #print text on diagonal graphs
}
}
#4 program part
A      = cbind(c(1,2,3),c(2,1,2),c(3,2,1))   # matrix A
u      = eigen(A)                            # eigenvalues and eigenvectors of A
u
gama   = u$vec                               # matrix of eigenvectors
gama
lambda = diag(u$val)                         # diagonal matrix containing the eigenvalues
lambda
#4 program part
A      = cbind(c(1,2,3),c(2,1,2),c(3,2,1))   # matrix A
u      = eigen(A)                            # eigenvalues and eigenvectors of A
gama   = u$vec                               # matrix of eigenvectors
gama
lambda = diag(u$val)                         # diagonal matrix containing the eigenvalues
lambda
gama%*%lambda%*%t(gama)                      # Jordan decomposition
-0.61*5.7
0.36*0.7
0.52*5.7
0.86*0.7
3.48*0.61-0.25*0.36-0.14*0.07
gama%*%lambda
#4 program part
A      = cbind(c(1,2,3),c(2,1,2),c(3,2,1))   # matrix A
u      = eigen(A)                            # eigenvalues and eigenvectors of A
gama   = u$vec                               # matrix of eigenvectors
gama
lambda = diag(u$val)                         # diagonal matrix containing the eigenvalues
lambda
gama%*%lambda%*%t(gama)                      # Jordan decomposition
gama%*%lambda
#4 program part
A      = cbind(c(1,2,3),c(2,1,2),c(3,2,1))   # matrix A
u      = eigen(A)                            # eigenvalues and eigenvectors of A
gama   = u$vec                               # matrix of eigenvectors
gama
lambda = diag(u$val)                         # diagonal matrix containing the eigenvalues
lambda
gama%*%lambda%*%t(gama)                      # Jordan decomposition
gama%*%lambda
3.48*0.61-0.25*0.36-1.42*0.07
0.52*0.61-0.86*0.36
0.52*5.7
3.48*0.61-0.25*0.36-1.42*0.71
delta(A)
u
5.7*0.7&+*2
5.7*0.7*2
inverse(lambda)
inv(lambda)
solve(lambda)
#compute A^(-1)
gama%*%solve(lambda)%*%t(gama)
#4 program part
A      = cbind(c(1,2,3),c(2,1,2),c(3,2,1))   # matrix A
u      = eigen(A)                            # eigenvalues and eigenvectors of A
gama   = u$vec                               # matrix of eigenvectors
gama
lambda = diag(u$val)                         # diagonal matrix containing the eigenvalues
lambda
gama%*%lambda%*%t(gama)                      # Jordan decomposition
#compute A^(-1)
gama%*%solve(lambda)%*%t(gama)
#compute A^2
gama%*%lambda%*%lambda%*%t(gama)
carc
knitr::opts_chunk$set(echo = TRUE)
carc<-read.table("mvadata/carc.dat")
carc
var(carc)
library(KernSmooth)
data(carc)
library(SMSdata)
data(carc)
var(carc$M,carc$W)
var(carc)
data("pullover")
pullover
cor(pullover)
data("pullover")
cor(pullover)
cor(pullover)[1,2]->rho
rho
log(exp(1))
r<--0.823
w<-1/2*log((1+r)/(1-r))
w
cor(pullover)[1,2]->r
w<-1/2*log((1+r)/(1-r))
z<-w/sqrt(1/nrow(pullover))
w*3
z
nrow(pullover)-3
w/sqrt(1/7)
cor(pullover)[1,2]->r
w<-1/2*log((1+r)/(1-r))
z<-w/sqrt(1/(nrow(pullover)-3))
z
cor(pullover)[1,2]->r
w<-1/2*log((1+r)/(1-r))
z<-w/sqrt(1/(nrow(pullover)-3))
z
w<-0.746
wstar<-w-(3*w+tanh(w))/(4*(nrow(pullover)-1))
wstar
cor(pullover)[1,2]->r
w<-1/2*log((1+r)/(1-r))
wstar<-w-(3*w+tanh(w))/(4*(nrow(pullover)-1))
z<-wstar/sqrt(1/(nrow(pullover)-1))
z
pullover
fit<-lm(Sales~Price,data=pullover)
fit
?predict
predict(fit,newdata=105)
predict(fit,105)
fit<-lm(Sales~Price,data=pullover)
predict(fit,data.frame(105))
fit<-lm(Sales~Price,data=pullover)
predict(fit,data.frame(Price=105))
fit<-lm(Sales~Price,data=pullover)
predict(fit,data.frame(Price=105))
shiny::runApp('~/Documents/GitHub/Spring2019-Proj2-grp8/apps')
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(gridExtra)
library(corrplot)
library(vcd)
library(caret)
library(tree)
library(randomForest)
library(gbm)
library(pROC)
?randomForest
runApp('~/Documents/GitHub/Spring2019-Proj2-grp8/apps')
runApp('~/Documents/GitHub/Fall2017-project2-grp6/app')
runApp('~/Documents/GitHub/Spring2019-Proj2-grp8/apps')
runApp('~/Documents/GitHub/Spring2019-Proj2-grp8/apps')
?textInput
runApp('~/Documents/GitHub/Spring2019-Proj2-grp8/apps')
runApp('~/Documents/GitHub/Spring2019-Proj2-grp8/apps')
runApp('~/Documents/GitHub/Spring2019-Proj2-grp8/apps')
load("../output/bus.stop.RData")
getwd()
setwd("/Users/xiaoxi/Documents/GitHub/Spring2019-Proj2-grp8/apps")
load("../output/bus.stop.RData")
runApp()
bus.stop
load("../output/bus.stop.RData")
bus.stop
load("../output/sub.station.RData")
runApp()
bus$lat
min(bus$lat)
runApp()
